# File: readBall.py
# Author: Harrison Inocencio
# Date: 07-17-18
# Purpose: 

# Notes:
# 1. If the readBall contains readFile's that are not of the same sample,
#	 sample_id will be set to 'None'
# 2.
# 3.
# 4.
# 5.

# TODO:
# 1. 
# 2.
# 3.
# 4.
# 5.

# -------------------------------------------------------------------

import subprocess
import lib.plumber
import lib.merge as merge
from lib.trim import trimmer
from lib.config.config import config

from lib.readFile import readFile # Imported for testing, not act needed

# readBall class
class readBall:
	"""
	Container for readFile objects. Should be used to group related
	sample read files, so that they can be merged and/or trimmed. 
	Once read processing is complete, their attributes can be 
	passed into a sampleBall.

	ATRS:
		run_id = id of the current run
		sample_id = shared sample number of all reads in the set, set to
					 'None' if members of the group differ in sample number
		fwd_set = lane sorted list of the R1 files in the set
		rev_set = lane sorted list of the R2 files in the set
		fwd_merge_rf = R1 merged rf obj
		rev_merge_rf = R2 merged rf obj
		inter_rf = Interleaved rf obj

		trim_obj = trimmer obj if applicable
		cbox = config obj

	"""

	# __init__ func
	# reads in a list of readFile objects grped by sample
	def __init__(self, laned_reads):
		self.__set_atr(laned_reads)

	# __set_atr func
	# sets the overall attributes of the readBall
	def __set_atr(self, laned_reads):
		self.run_id = laned_reads[0].run_id
		# if their is a != sample in laned_reads, set sample_id to 'None'
		if all(x.sample == laned_reads[0].sample for x in laned_reads):
			self.sample_id = laned_reads[0].sample
		else:
			self.sample_id = None
		# Set fwd and rev sets
		self.fwd_set, self.rev_set = self.__sort(laned_reads)

		# Set merge rf's to 'None'. These rf's will be generated by
		# running 'merge' and can be overwritten by 'trim'. Also init
		# trim obj and inter_rf, which is set through 'interleave'
		self.fwd_merge_rf = None
		self.rev_merge_rf = None
		inter_rf = None
		self.trim_obj = None

		# config obj
		self.cbox = config()
		
		# Check that config loaded correctly using "check_path"
		try:
			self.cbox.check_path()
		except FileNotFoundError:
			raise(RuntimeError("Missing Config"))

	# __sort func
	# groups objs by direction and sorts them by lane
	def __sort(self, laned_reads):
		fwd_set = []
		rev_set = []
		for obj in laned_reads:
			if obj.direction == "R1":
				fwd_set.append(obj)
			else:
				rev_set.append(obj)
		fwd_set.sort(key=lambda f: f.lane)
		rev_set.sort(key=lambda r: r.lane)

		return fwd_set, rev_set

	# merge_ball func
	# merges the fwd_set and rev_set read files into two merged files,
	# writing them out to merge_dir and setting the [fwd/rev]_merge_rf atr
	# to the generated readFile obj
	def merge_ball(self, merge_path):
		self.fwd_merge_rf = merge.merge_helper(self.fwd_set, merge_path)
		self.rev_merge_rf = merge.merge_helper(self.rev_set, merge_path)

	# trim_ball func
	# trims the fwd/rev merged files using the provided trim_args
	# overwrites the [fwd/rev]_merge_rf attributes with these trimmed
	# files upon completion
	def trim_ball(self, trim_path, trim_args):
		self.trim_obj = trimmer(self, trim_path, trim_args)
		self.fwd_merge_rf, self.rev_merge_rf = self.trim_obj.run()

	# __gen_inter_name func
	# Returns the interleave file name for this sample
	def __gen_inter_name(self):
		return "%s-%s_%s_all_interleaved_001.fastq" % (
										self.run_id, self.sample_id,
										self.sample_id)

	# interleave func
	# Interleaves the fwd/rec rf's and assigns the resulting rf
	# to the inter_rf atr
	def interleave(self, inter_dir):
		inter_path = inter_dir + self.__gen_inter_name()
		#print(inter_path)
		with open(inter_path, 'w') as out_file:
			with open(self.fwd_merge_rf.fpath) as f1:
				with open(self.rev_merge_rf.fpath) as f2:
					while True:
						line = f1.readline()
						if line.strip() == "":
							break
						out_file.write(line.strip()+"\n")
						for i in range(3):
							out_file.write(f1.readline().strip()+"\n")
						for i in range(4):
							out_file.write(f2.readline().strip()+"\n")

		self.inter_rf = readFile(inter_path)
		#self.inter_rf.tprint()

	# tprint func
	# print various info on attributes (for testing ...)
	# 1. sample_id :
	# 2. fwd_set: prints the fname of each readFile ele
	# 3. rev_set: ...
	# 4. fwd_merge_rf: prints fpath and fname
	def tprint(self):
		print(self.sample_id)
		for obj in self.fwd_set:
			print(obj.fname)
		for obj in self.rev_set:
			print(obj.fname)
		try:
			print(self.fwd_merge_rf.fpath)
			print(self.fwd_merge_rf.fname)
		except AttributeError:
			print(None)
		try:
			print(self.rev_merge_rf.fpath)
			print(self.rev_merge_rf.fname)
		except AttributeError:
			print(None)
		try:
			print(self.inter_rf.fpath)
			print(self.inter_rf.fname)
		except AttributeError:
			print(None)

		print()
