#!/usr/bin/env python3

# File: bioPipe
# Author: Harrison Inocencio
# Date: 07-17-18
# Purpose: contains the bioPipe class, which is the top level class
#		   and can be used to run the pipeline. Executing this script
#		   will start the pipeline

# Usage: Can be executed as a script

# Notes:
# 1. # Descriptive comment
# 2. ## Debug print comment
# 3. ### Needs to be uncommented before completion
# 4.
# 5.

# TODO:
# 1. Fix hardcoding! (Not just in this script either)
# 2.
# 3.
# 4.
# 5.

# -------------------------------------------------------------------

import os
import lib.args as args
import lib.plumber as plumber
from lib.readFile import readFile
from lib.readBall import readBall
#from lib.analysisModule import analysisModule

# bioPipe class
class bioPipe:
	"""
	bioPipe class calls all other classes, and is the top level
	object for the pipeline. Can be run directly to execute the pipeline

	ATRS:
		PRE-RUN
		target_dir = dir containing reads
		output_dir = output directory

		ON-RUN
		read_pit = master list of readBall objects

	"""

	# __init__ func
	# sets attributes to arguments specified in arg_dic
	def __init__(self, arg_dic):
		self.target_dir = arg_dic.read_dir
		self.output_dir = arg_dic.output_dir
		self.trim_args = arg_dic.trim_args
	
	# __run_init func
	# inits a pipe run, checks dirs, mks output dir, return fastq list
	def __run_init(self):
		# Add terminal backslash to dirs if absent
		if self.target_dir[-1] != "/":
			self.target_dir+="/"
		if self.output_dir[-1] != "/":
			self.output_dir+="/"
		
		# Return fastq list
		fastq_list = []
		for item in os.listdir(self.target_dir):
			if ".fastq" in item:
				fastq_list.append(self.target_dir+item)

		return fastq_list

	# __mass_merge func
	# Calls the 'merge' function for each readBall in the master_list
	def __mass_merge(self):
		merge_path = self.output_dir+args.merge_dir
		print("\tMerge path set to", merge_path)
		plumber.force_dir(merge_path)
		for rball in self.read_pit:
			print("\t\tMerging sample %s ..." % rball.sample_id)
			rball.merge_ball(merge_path)

	# __mass_trim func
	# Calls 'trim' for each readBall. Only run as a secondary step if 
	# the args specify for it
	def __mass_trim(self):
		trim_path = self.output_dir+args.trim_dir
		print("\tTrim path set to", trim_path)
		print("\tTrim args set to \"%s\"" % self.trim_args)
		plumber.force_dir(trim_path)
		for rball in self.read_pit:
			print("\t\tTrimming sample %s ..." % rball.sample_id)
			rball.trim_ball(trim_path, self.trim_args)

	# run func
	# Starts the pipe
	def run(self):
		print("Beginning Pipe ...")
		print("Initializing ...")
		### plumber.force_dir(self.output_dir)
		fastq_list = self.__run_init()
		print("Building Pit ...")
		self.read_pit = plumber.build_read_pit(fastq_list)
		print("Beginning Merges ...")
		### self.__mass_merge()
		# Trim if called
		### if self.trim_args != None:
		###	"Trim called, beginning trims ..."
		###	self.__mass_trim()
		
		test_rfs1 = [readFile("test_out/trimmed/4560-S1_trimmmed/4560-S1_S1_all_R1_paired.fastq")]
		trball = readBall(test_rfs1)
		trball.fwd_merge_rf = readFile("test_out/trimmed/4560-S1_trimmmed/4560-S1_S1_all_R1_paired.fastq")
		trball.rev_merge_rf = readFile("test_out/trimmed/4560-S1_trimmmed/4560-S1_S1_all_R2_paired.fastq")

		trball.tprint()
		tpit = [trball]

		# Create analysis module
		#module = analysisModule(read_pit):
		#analysisMoudle()

		print("Closing Pipe ...")

# main func
# Called when file is executed instead of imported
def main():
	arg_dic = args.parse()
	pipe = bioPipe(arg_dic)
	pipe.run()

if __name__ == '__main__':
	main()
